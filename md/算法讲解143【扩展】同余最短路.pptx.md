<!-- Slide number: 1 -->
# 同余最短路
左程云
前置知识
讲解059 - 链式前向星建图
讲解062 - 01bfs
讲解064 - Dijkstra算法
讲解074 - 完全背包

本节课讲述，总体积极大，单个物品体积较小，这一类完全背包问题，用同余最短路解决，具体包括
同余分组的概念
dijkstra算法实现同余最短路
01bfs算法实现同余最短路
两次转圈法实现同余最短路

注意如下都是之前讲的题目，都是同余分组解决的，虽然没看过也不会影响本节课的学习，但推荐观看
讲解075 - 题目4多重背包单调队列优化，题目5混合背包    讲解105 - 题目5串联所有单词的子串

<!-- Slide number: 2 -->
# 同余最短路
左程云
同余最短路
给定n个正数，每种数的个数无限
求这n个正数能拼凑出多少的其他数
或者不能拼凑出的最小数、最大数等问题时

利用同余最短路构造一些同余状态，可以起到优化时间和空间的目的

<!-- Slide number: 3 -->
# 同余最短路
左程云
题目1
跳楼机
一座大楼一共有h层，楼层编号1~h，有如下四种移动方式
1, 向上移动x层
2, 向上移动y层
3, 向上移动z层
4, 回到1层
假设你正在第1层，请问大楼里有多少楼层你可以到达
1 <= h <= 2^63 - 1
1 <= x、y、z <= 10^5
测试链接 : https://www.luogu.com.cn/problem/P3403

dijkstra算法实现同余最短路

<!-- Slide number: 4 -->
# 同余最短路
左程云
题目2
牛场围栏
给定一个长度为n的数组arr, arr[i]代表第i种木棍的长度，每种木棍有无穷多个
给定一个正数m，表示你可以把任何一根木棍消去最多m的长度，同一种木棍可以消去不同的长度
你可以随意拼接木棍形成一个长度，返回不能拼出来的长度中，最大值是多少
如果你可以拼出任何长度，返回-1
如果不能拼出来的长度有无穷多，返回-1
1 <= n <= 100
1 <= arr[i] <= 3000
1 <= m <= 3000
测试链接 : https://www.luogu.com.cn/problem/P2662

dijkstra算法实现同余最短路

<!-- Slide number: 5 -->
# 同余最短路
左程云
题目3
正整数倍的最小数位和
给定一个整数k，求一个k的正整数倍s，使得在十进制下，s的数位累加和最小
不返回s，而是返回这个最小的数位和
2 <= k <= 10^5
测试链接 : https://www.luogu.com.cn/problem/AT_arc084_b
测试链接 : https://atcoder.jp/contests/abc077/tasks/arc084_b

巧妙构造 + 01bfs算法实现同余最短路

<!-- Slide number: 6 -->
# 同余最短路
左程云
题目4
墨墨的等式
一共有n种正数，每种数可以选择任意个，个数不能是负数
那么一定有某些数值可以由这些数字累加得到
请问在[l...r]范围上，有多少个数能被累加得到
0 <= n <= 12
0 <= 数值范围 <= 5 * 10^5
1 <= l <= r <= 10^12
测试链接 : https://www.luogu.com.cn/problem/P2371

解法1，dijkstra算法实现同余最短路

解法2，两次转圈法实现同余最短路，课上重点详解两次绕圈法

<!-- Slide number: 7 -->
# 同余最短路
左程云
两次转圈法实现同余最短路

给定一个基准数x，那么可能的余数为0..x-1
假设当前余数是cur，当前出现数字为y，(cur + y) % x 所出现的新余数，最终会回到cur
当前出现数字为y，0..x-1这些点，会形成gcd(x,y)个子环，所有子环的起点为：0 ~ gcd(x,y)-1

每个子环为单位，进行同余最短路的更新，所有子环的所有点的数量 = x，即更新一轮的代价O(x)
因为是最短路，所以每出现一个新的数字y，所形成的每个子环，只需要转一圈即可完成更新
特别注意：子环的起点不一定是点权最小的点，所以实现中，往往用转两圈的方式

如果一共有n个数字，基准数为x，那么同余最短路的更新代价为，O(n * x)
spfa算法也可以实现同余最短路的更新，但是比赛中经常设计数据，让其时间复杂度高于O(n * x)
为了顺利通过，所以更推荐两次绕圈法

<!-- Slide number: 8 -->
# 同余最短路
左程云
题目5
背包
一共有n种物品，第i种物品的体积为v[i]，价值为c[i]，每种物品可以选择任意个，个数不能是负数
一共有m条查询，每次查询都会给定jobv，代表体积的要求
要求挑选物品的体积和一定要严格是jobv，返回能得到的最大价值和
如果没有方案能正好凑满jobv，返回-1
1 <= n <= 50
1 <= m <= 10^5
1 <= v[i] <= 10^5
1 <= c[i] <= 10^6
10^11 <= jobv <= 10^12
测试链接 : https://www.luogu.com.cn/problem/P9140

贪心决定基准物品 + 数据范围分析 + 两次转圈法实现同余最长路